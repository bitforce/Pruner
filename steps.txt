CLEANER
=======
clean
clean -ws -a A...-f F... -d D...
clean N -ws -a A...-f F... -d D...

run:
    IF ! $# -eq 0
      IF $1 IS INTEGER && $# -gt 1
        # go up to root, add these new $args, clean, then come back down
        curr=$pwd
        backup() $1 # to root based on cd.. $1 times
        $args = THIS
      ELIF $1 IS INTEGER && -eq 1
        # go up to root and clean, then come back down
      ELSE 
        # add these things and clean
        $args = THIS
      validate() $args
      add() $args # adds args to .clean file
      clean() # reads from .clean file and removes all those things
      cd $pwd
    ELSE
      clean()

clean:
  # follows process 

backup:
  currdir=$pwd
  for i in $1 -> cd ..
  IF ! $pwd contains() '.clean'
    echo 'could not find .clean -> appears not to be root'
    terminate()




--------------------------------------------------------------------------------

1. user runs clean command --> command check for .clean file
    Command knows that this is the first time it is being run because there 
exists no .clean file.

2A. clean file exists but it was not created by command
    Command lets user know that they already have a hidden clean file and ask 
whether or not to remove it.
2B. clean file exists and it was created by command
    Command simply "cleans" based on users specs from .clean file.
2C. clean file does not exist
    Command creates new .clean file based on user specs.

3.


GENERAL ALGO
if "CLEAN" run:
    if .clean exists -> check 1st line for following:
        ------------
        A CLEAN FILE
        ------------
        if THIS exists, then execute_instructions($2, $3)
        else duplicate_file_error() // out > "You appear to have a duplicate file"

execute_instructions(arguments):
if arg == -s -> suppress_output()
if arg == -w -> overwrite(next_args)
if arg == -f -> add_files(next_args)
if arg == -d -> add_dirs(next_args)
